

# This file was *autogenerated* from the file param.sage
from sage.all_cmdline import *   # import sage library

_sage_const_2048 = Integer(2048); _sage_const_29 = Integer(29); _sage_const_100000 = Integer(100000); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_4 = Integer(4); _sage_const_0 = Integer(0); _sage_const_6 = Integer(6); _sage_const_680 = Integer(680); _sage_const_256 = Integer(256); _sage_const_1p4 = RealNumber('1.4')# Find the bigger modulus Q s.t. q = 1 mod 2N
N = _sage_const_2048 
Qbit = _sage_const_29 
for i in range(_sage_const_100000 ):
	if is_prime(_sage_const_2 **Qbit-i) and (_sage_const_2 **Qbit-i)%(_sage_const_2 *N) == _sage_const_1 :
		Q = _sage_const_2 **Qbit-i
		print ("Q = 2^" + str(Qbit)+ "-" + str(i) + ' = ' + str(Q))
		print ("factor(Q-1) = " + str(factor(Q-_sage_const_1 )))
		break

# Find the invertible parameter u \approx Q/2t
t = _sage_const_4 
F = GF(Q)
u = round(Q/(_sage_const_2 *t))
u_inv = F(u)**(-_sage_const_1 )
u_inv = int(u_inv)
if u_inv > Q/_sage_const_2 :
	u_inv = u_inv - Q
print ("u = Q/2t = " + str(u))
print ("u_inverse = " + str(u_inv))

# find the primitive root of unity

gen = primitive_root(Q)
gen = mod(gen,Q)

g_list = []
prime_factor = [ i[_sage_const_0 ] for i in list(factor(Q-_sage_const_1 )) ]

testv = [(Q-_sage_const_1 )/i for i in prime_factor]
for gen in range(_sage_const_1 , Q):
	flag = True
	gen = mod(gen, Q)
	for v in testv:
		if gen**v == _sage_const_1 :
			flag = False
			break
	if flag == True:
		# print ("primitive generator of Q is: " + str(gen))
		g_list.append(gen)
		break

root_2Nth_list = []
root_Nth_list = []
for gen in g_list:
	root_2Nth_list.append( gen**((Q-_sage_const_1 )/(_sage_const_2 *N)) )
	root_Nth_list.append( gen**((Q-_sage_const_1 )/N) )

root_2Nth = root_2Nth_list[_sage_const_0 ]
root_Nth = root_Nth_list[_sage_const_0 ]

tmp = int(gen)
if tmp > Q/_sage_const_2 :
	tmp = tmp - Q
print ( "primitive generator of Q is: " + str(tmp) )

tmp = int(root_2Nth)
if tmp > Q/_sage_const_2 :
	tmp = tmp - Q
print ( "primitive 2N-th root of unity of Q is: " + str(tmp) )

tmp = int(root_Nth)
if tmp > Q/_sage_const_2 :
	tmp = tmp - Q
print ( "primitive N-th root of unity of Q is: " + str(tmp) )

tmp = int(root_2Nth**(-_sage_const_1 ))
if tmp > Q/_sage_const_2 :
	tmp = tmp - Q
print ( "inverse primitive 2N-th root of unity of Q is: " + str(tmp) )

tmp = int(root_Nth**(-_sage_const_1 ))
if tmp > Q/_sage_const_2 :
	tmp = tmp - Q
print ( "inverse primitive N-th root of unity of Q is: " + str(tmp) )

tmp = int(mod(N, Q))
print ( "N mod Q is: " + str(tmp) )

tmp = int( (mod(N, Q))**(-_sage_const_1 ) )
if tmp > Q/_sage_const_2 :
	tmp = tmp - Q
print ( "inverse N mod Q is: " + str(tmp) )


# find omega's psi's for NTT computation
omega_list = []
psi_list = []
omega_inv_list = []
psi_inv_list = []
for i in range(N):
	omega_list.append(root_Nth**i)
	psi_list.append(root_2Nth**i)
	omega_inv_list.append(root_Nth**(-i))
	psi_inv_list.append(root_2Nth**(-i))

# find vgprime = [u, u<<6, u<<12, u<<18, u<<24, u<<30]
vgprime = []
Bg = _sage_const_2 **_sage_const_6 
log_Bg = log(Bg, _sage_const_2 )
for i in range(ceil(Qbit/log_Bg)):
	tmp = int(mod(u*Bg**(i),Q))
	if tmp > Q/_sage_const_2 :
		tmp = tmp - Q
	vgprime.append(tmp)
print (vgprime)



# estimate the security by using uSVP, decoding, and dual attacks.
n = _sage_const_680 
q = _sage_const_256 
sigma = _sage_const_1p4 
load("../../../malb-lwe-estimator-fb7deba98e59/estimator.py")

# estimate LWE
print ("LWE security esitmation as follows:")
n = n; q = q; stddev = sigma; alpha = alphaf(sigmaf(stddev), q)
_ = estimate_lwe(n, alpha, q, secret_distribution=((-_sage_const_1 ,_sage_const_1 ),n/_sage_const_2 ), reduction_cost_model=BKZ.sieve)

# estimate RLWE
print ("RLWE security esitmation as follows:")
n = N; q = Q; stddev = sigma; alpha = alphaf(sigmaf(stddev), q)
_ = estimate_lwe(n, alpha, q, reduction_cost_model=BKZ.sieve)

